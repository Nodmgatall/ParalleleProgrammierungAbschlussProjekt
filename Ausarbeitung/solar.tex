\title{Simulation eines Sonnensystems}
%TODO :
\subtitle{Praktikumsbericht}

\author{Oliver Heidmann, Tronje Krabbe}

\institute{Universität Hamburg \\ 
  Fakultät für Mathematik, Informatik und Naturwissenschaften \\
  Fachbereich Informatik, DKRZ \\
  Praktikum Paralleles Programmieren 2015}
  
\date{\today}

\maketitle

%\index{personen}{Krabbe, Tronje}
\newpage
\begin{abstract}
%TODO content
\quad \\
Aufgabenstellung: \\
Programmierung einer parallelisierten Applikation mittels MPI. \\ \\
Idee: \\
Simulation von Partikeln in einem Sonnensystem.
%\keywords{Keywords}
\end{abstract}

\tableofcontents
\newpage
\section{Idee}
Die Idee, die unserem Projekt zugrunde liegt, ist relativ simpel zu formulieren:
Wir wollen ein Sonnensystem simulieren. In diesem System sollten die enthaltenen
Objekte realistisch miteinander interagieren. Alle Objekte beinflussen sich durch
die Gravitation und durch physischen Kontakt also Kollisionen. 

\section{Modellierung}
In unserem System
wird die Bewegung des ganzen Systems nicht beruecktsichtig und somit ist die 
Geschwindigkeit und die Position des sich in der Mitte befindlichen massereichesten
Objektes fixiert.
Kollisionen sind nur teilweise realistisch umgesetzt. Bei einer Kollision werden
zwei Objekte miteinder verschmolzen und es werden keine weiteren kleineren Objekte
erzeugt.
Alle einheiten sind in SI-Einheiten.

%\subsection{Das System}
%Wie bereits erwähnt ist die Welt, in der unsere Simulation stattfindet,
%ein System analog zu einem echten Sonnensystem. Es ist nicht räumlich begrenzt,
%und enthält eine beliebige Anzahl Partikel. Kollidieren zwei Partikel, so wird aus ihnen
%ein neues Partikel errechnet, die Population schrumpft also nur; es werden keine neuen
%hinzugefügt.

%\begin{minipage}[t]{0.48\textwidth}
%    Dreidimensionaler raum mkay?
%\end{minipage}
%\begin{minipage}[t]{0.48\textwidth}
%	\begin{picture}(0,0)
%		\put(20,-75){\includegraphics[scale=0.35]{pics/Torus.png}}
%	\end{picture}
%\end{minipage}	

\subsection{Die Partikel}
Partikel haben folgende Eigenschaften:
\begin{itemize}
    \item Geschwindigkeitsvektor
    \item Position
    \item Masse
    \item Radius
\end{itemize}
Wir gehen von sphärischen Objekten aus. Spezifische Details
Material, Temperatur oder genaure Form werden nicht berücksichtigt.
Partikel werden immer in einer zur sonne ortogonalen laufbahn generiert
um die Anzahl von Objekten die eine stabile Umlaufbahn erreichen koennen
zu steigern. Die Dichte von Objekten wird nicht als Datensatz geschpeichert
sondern nur bei bedarf errechnet um die Datenmenge zu reduzieren.

\subsection{Das Zentrum}
Im Zentrum unseres Systems befindet sich ein Partikel mit einer besonderen
Eigenschaft. Es ist vielfaches schwerer als die zufällig generierten Objekte.
Die Existenz dieses Zentralpartikels bewirkt einerseits eine übersichtliche Simulation,
da sich die meisten Partikel irgendwann auf einem Orbit um die `Sonne' finden,
und bringt die Simulation näher an die tatsächlichen Zustände in unserem Universum.

\subsection{Ablauf}
Der Ablauf der Simulation ansich ist relativ simpel; die Partikel werden sortiert,
auf alle die Gravitation appliziert; es wird auf Kollisionen geprüft und dann werden
die Objekte bewegt. Dieser loop wird für die spezifizierte Anzahl Iterationen
fortgeführt.

Die Parallelisierte Version hat eine andere Reinfolge.
Hier haben wir die Kollisionsabfrage vor den Bewegungsbefehl und die Errechnung
der neuen geschwindigkeiten verlegt. Dies geschah um den datentransfaer zwischen
den einzelnen Prozessen zu veringern.

\subsection{Visualisierung}
Zum Zweck der Visualizierung werden für jede Iteration und für jedes Partikel seine
Eigenschaften gespeichert. Diese Daten können dann von einem separaten Programm,
unserem Visualizer, eingelesen und die Simulation damit dargestellt werden.


\section{Implementation}
\subsection{Allgemein}
Den Kern der Simulation bildet die Klasse `Particle':
\begin{minted}{C++}
class Particle
{
    private:
        std::vector<Vec3<double> > m_velocity_vectors;
        std::vector<Vec3<double> > m_positions;
        std::vector<double> m_masses;
        std::vector<double> m_radiuses;
        std::vector<unsigned long> m_ids;
        unsigned long m_number_of_particles;

    /* [...] */
}
\end{minted}

\subsection{Parallelisierungsschema}
TODO

\begin{minted}{C++}
#include <Heidmann.h>
std::cout << "lol" << std::endl;
\end{minted}
%\quad \\


\subsection{Visualizer}
Der Visualizer visualisiert eine fertige Simulation anhand der generierten Daten.
Es handelt sich dabei um ein separates Programm, ebenfalls in C++ geschrieben,
mit Hilfe von SDL2.

\section{Performance}
ayy lmao

\section{Probleme}
Ein Problem bei der Parallelisierung war die Datenaufteilung. Da Gravitation einen effektiv
unendlichen Einflussradius hat, muss jeder Prozess die gesamten, aktuellen Daten aller
Partikel kennen.

\section{Fazit und Ausblick}
\subsection{Fazit}
Das haben wir gelernt
\subsection{Ausblick}
locker machen wir noch mehr Dinge (lolol)

%\pagebreak
%\nocite{*}
