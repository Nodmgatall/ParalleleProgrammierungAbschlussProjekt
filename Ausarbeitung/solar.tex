\title{Simulation eines Sonnensystems}
%TODO :
\subtitle{Praktikumsbericht}

\author{Oliver Heidmann, Tronje Krabbe}

\institute{Universität Hamburg \\ 
  Fakultät für Mathematik, Informatik und Naturwissenschaften \\
  Fachbereich Informatik, DKRZ \\
  Praktikum Paralleles Programmieren 2015}
  
\date{\today}

\maketitle

%\index{personen}{Krabbe, Tronje}
\newpage
\begin{abstract}
%TODO content
\quad \\
Aufgabenstellung: \\
Programmierung einer parallelisierten Applikation mittels MPI. \\ \\
Idee: \\
Simulation von Partikeln in einem Sonnensystem.
%\keywords{Keywords}
\end{abstract}

\tableofcontents
\newpage
\section{Idee}
Die Idee, die unserem Projekt zugrunde liegt, ist relativ simpel zu formulieren:
Wir wollen ein Sonnensystem simulieren. In diesem System sollten die enthaltenen
Objekte realistisch miteinander interagieren. Alle Objekte beinflussen sich durch
die Gravitation und durch physischen Kontakt also Kollisionen. 

\section{Modellierung}
In unserem System
wird die Bewegung des ganzen Systems nicht beruecktsichtig und somit ist die 
Geschwindigkeit und die Position des sich in der Mitte befindlichen massereichesten
Objektes fixiert.
Kollisionen sind nur teilweise realistisch umgesetzt. Bei einer Kollision werden
zwei Objekte miteinder verschmolzen und es werden keine weiteren kleineren Objekte
erzeugt.
Alle einheiten sind in SI-Einheiten.

%\subsection{Das System}
%Wie bereits erwähnt ist die Welt, in der unsere Simulation stattfindet,
%ein System analog zu einem echten Sonnensystem. Es ist nicht räumlich begrenzt,
%und enthält eine beliebige Anzahl Partikel. Kollidieren zwei Partikel, so wird aus ihnen
%ein neues Partikel errechnet, die Population schrumpft also nur; es werden keine neuen
%hinzugefügt.

%\begin{minipage}[t]{0.48\textwidth}
%    Dreidimensionaler raum mkay?
%\end{minipage}
%\begin{minipage}[t]{0.48\textwidth}
%	\begin{picture}(0,0)
%		\put(20,-75){\includegraphics[scale=0.35]{pics/Torus.png}}
%	\end{picture}
%\end{minipage}	

\subsection{Die Partikel}
Partikel haben folgende Eigenschaften:
\begin{itemize}
    \item Geschwindigkeitsvektor
    \item Position
    \item Masse
    \item Radius
\end{itemize}
Wir gehen von sphärischen Objekten aus. Spezifische Details
Material, Temperatur oder genaure Form werden nicht berücksichtigt.
Partikel werden immer in einer zur Sonne ortogonalen Laufbahn generiert
um die Anzahl von Objekten die eine stabile Umlaufbahn erreichen koennen
zu steigern. Die Dichte von Objekten wird nicht als Datensatz geschpeichert
sondern nur bei Bedarf errechnet um die Datenmenge zu reduzieren.

\subsection{Das Zentrum}
Im Zentrum unseres Systems befindet sich ein Partikel mit einer besonderen
Eigenschaft. Es ist vielfaches schwerer als die zufällig generierten Objekte.
Die Existenz dieses Zentralpartikels bewirkt einerseits eine übersichtliche Simulation,
da sich die meisten Partikel irgendwann auf einem Orbit um die `Sonne' finden,
und bringt die Simulation näher an die tatsächlichen Zustände in unserem Universum.

\subsection{Ablauf}
Der Ablauf der Simulation ansich ist relativ simpel; die Partikel werden sortiert,
auf alle die Gravitation appliziert; es wird auf Kollisionen geprüft und dann werden
die Objekte bewegt. Dieser loop wird für die spezifizierte Anzahl Iterationen
fortgeführt.

Die Parallelisierte Version hat eine andere Reinfolge.
Hier haben wir die Kollisionsabfrage vor den Bewegungsbefehl und die Errechnung
der neuen geschwindigkeiten verlegt. Dies geschah um den datentransfaer zwischen
den einzelnen Prozessen zu veringern.

\subsection{Visualisierung}
Zum Zweck der Visualizierung werden für jede Iteration und für jedes Partikel seine
Eigenschaften gespeichert. Diese Daten können dann von einem separaten Programm,
unserem Visualizer, eingelesen und die Simulation damit dargestellt werden.


\section{Implementation}
\subsection{Allgemein}
Den Kern der Simulation bildet die Klasse `Particle':
\begin{minted}{C++}
class Particle
{
    private:
        std::vector<Vec3<double> > m\_velocity\_vectors;
        std::vector<Vec3<double> > m\_positions;
        std::vector<double> m\_masses;
        std::vector<double> m\_radiuses;
        std::vector<unsigned long> m\_ids;
        unsigned long m\_number\_of\_particles;

    /* [...] */
}
\end{minted}

\subsection{Parallelisierungsschema}
In unserer Simulation uebernimmt Prozess 0 immer die Verwaltung der Daten und somit das Verteilen
und Sammeln. Hinzu kommt das Speichern der Simulationsdaten und die Ausgabe des Fortschritts.
Alle anderen Prozesse empfangen die Daten bearbeiten sie und senden dann die
durch die Kollisionsabfrage geaenderte Laenge des Datensatzes an Prozess 0
und daruf hin die geaenderten Daten.

Funktions weise:
   ALLE:
       - variablen initialisierung am Anfang
       - erhoen des privaten zaehlers am Ende
   Prozess 0:
       - prozess 0 errechnet die anteile an den Datenvektoren des Systems
       - sortiert die Vektoren nach der Entfernung zum Mittelpunkt 
       - broadcastet die Objekt Anzahl
       - broadcastet nacheinander die Datenvektoren
       - erhaelt dann in richtiger Reinfolge die neu berechneten Daten und fuegt sie wieder zusammen
       - ueberscheibt seine alten Daten mit den neuen
       - speichert sie
   Prozess 1 - n
       - empfaengt die Broadcasts von 0
       - erechnet seine start und end positionen in den vektoren
       - berechnet collisionen
       - aendert die laenge der zu bearbeitenden Daten
       - berechnet die neunen geschwindigkeiten
       - berechnet die neuen positionen
       - sendet neue positionen
       - sendet neue geschwindigkeiten

\begin{minted}{C++}
#include <Heidmann.h>
std::cout << "lol" << std::endl;
\end{minted}
%\quad \\


\subsection{Visualizer}
Der Visualizer visualisiert eine fertige Simulation anhand der generierten Daten.
Es handelt sich dabei um ein separates Programm, ebenfalls in C++ geschrieben,
mit Hilfe von SDL2.

Integriert ist eine Provisorische Konsole und mehrere hotkeys fuer die einfache Benutzung


Kommandos:

long name           shot\_name           argument\_type                   arguments

draw\_ids                dis             none
draw\_it\_number          din             none
show\_particle\_number    spn             none
show\_simulated\_time     sst             none    
show\_delta\_time         sdt             none    
display\_data            dd              (unsigned long)                 [onject\_id]
show grav\_range         sgr             (unsigned long) (double)        [object\_id][min\_force]
focus\_on\_object         fon             (unsigned long)                 [object\_id]
clear\_displayed\_data    cdd             none 
jump\_to\_time            jmp             (unsigned long)                 [interation]
show\_trajectory         st              (unsigned long) (unsigned long) [object\_id] [iteration]
clear\_trajectory        st              (unsigned long)                 [object\_id]
clear\_all\_trajectories cat             none

Commands explanation:

draw\_ids:
    draws object ids of all objects
    clears object ids

draw\_it\_number:
    draws the current interation number in the top right corner
    clears iteration number

draw\_particle\_number:
    draws the current number of particles
    clears particle number

show\_simulated time:
    draws the elapsed time in y* dd hh
    clears simulated time

show\_delta\_time:
    shows how much time is calculated in one iteration (in seconds)
    clears delta time

display\_data:
    shows the velo, pos, radius, distance to sun, mass of given object
    clear displayed date for given object

show\_grav\_range:
    draws a rircle around given object in which radius the gravitational force is larger than min\_force
    clear the circle for given object

focus\_on\_object:
    sets the camera to given obeject

clear\_displayed\_data:
    clears all object data from screen (counter to display data)

jump\_to\_time:
    jumps to given iteration

show\_trajectory:
    draws the trajectory of given object.
    the second arguments is for limiting the length of the line
    if there is no second argument the complete trajectory is drawn which can cause lag if
    sufficient iterations are loaded

clear\_all\_trajectories:
    clears all trajectories

Hotkeys:

p:          pause/unpause
s:          step forward
b:          step backward
r:          reset to iteration 0
x/y:        change perspective
enter:      start input for commands/ confirm
esc:        quit
up:         move camera up
down:       move camera down
left:       move camera left
right:      move camera right
mousewheel: zoom


\section{Performance}
ayy lmao

\section{Probleme}
Ein Problem bei der Parallelisierung war die Datenaufteilung. Da Gravitation einen effektiv
unendlichen Einflussradius hat, muss jeder Prozess die gesamten, aktuellen Daten aller
Partikel kennen.

Besonders die Kollisionsabfrage benoetigt alle Daten da bei einer Kollision der Komplette
Datensatz fuer das Objekt geloescht werden muss.

\section{Fazit und Ausblick}
\subsection{Fazit}
Das haben wir gelernt
\subsection{Ausblick}
Fuer die Zukunft des Projektes sind folgende Features geplant:
    Simulation:
        - Redukion der zu verchickenden Daten durch refactoring der Kollisionsabfrage
          z.B nur die ids der Kollisionspartner speichern und spaeter Prozess 0 das loeschen
          der Daten ueberlassen
        - neu strukturiertes Senden und Empfangens
        - erweiterung des sendes fuer Datensaetze die die maximale
          Bufferlaenge von mpi ueberschreiten
        - performantere Kollisionsabfrage
        - physikalisch korrekte errechnung von Kollisionen und den
          Richtungsvektoren der daraus resultierenden neuen Objekte sowie
          die errechnung der anzahl der generierten Objekte
        - zusaetzliche daten zb durchschnitts Temperatur
        - genauere angeaben welche daten gespeichert werden und welche nicht
        - Errechnung und Speicherung fuer Kollsionsdaten z.B. impuls, Ekin,
          geschwindigkeit bei einschlag etc.
        - Berechnung der Roche-Grenze und die zerstoerung von Objekten 
          durch diese Grenze.
        - Parallelisierte Erstellung der Objekte
        - Parallelisierter Sort-Algorithmus
        - Verbesserung des Sort-Algorithmuses
        - Ausschreiben von Kollisonsdaten

    Visualizer:
        - laufbahnen als lienen darstellen
        - lienen der Laufbahnen auf wunsch der Geschwindikeit entsprechend
          einfaerben
        - temperatur Berechnung
        - Objekte bei einem gewissen Zoomfaktor als kreise Darstellen
        - Visualizer in 3D oder wenigstens rotierbar in 2 achsen
        - UI-Verbesserungen
        - Konsolenfenster
        - Objekt daten in Repositionierbaren Fenstern
        - Repositionierbare fuer die Simulationsdaten wie die Anzahl der Objekte
        - Klassen der Objekte anzeigen und errechnen z.B. M klasse Planet, Asterioid etc.
        - Performance verbesserungen inbesondere in Bezug auf die Flugbahn erstellung
        - Markierung von Kollisionspunkten

\section{Zahlen}
\begin{itemize}
    \item ~2700 Zeilen Code
    \item 163 Commits bis jetzt
    \item $>$20 Gb generierte Simulations-Daten
\end{itemize}

%\pagebreak
%\nocite{*}
